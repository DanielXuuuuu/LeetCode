# 下一个排列

### 题目

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`



### 解题

一般寻找下一个排序的思路就是，从后往前看，把较大的数换到前面来。而对于降序的排列，例如`3,2,1`就不存在下一个排列了，必须把整个数组翻转。

基于以上思路，我们先寻找到末尾最长的下降子序列，对于这个子序列而言，必定是不存在对于这个序列内部进行交换就可以使得整个原排列变大的可能性的。那么，我们就需要对于这个子序列前的元素a进行调整。怎么调整呢？找到下降子序列中最小的且大于a的元素和a进行交换，然后再对子序列进行翻转即可。

举个例子，例如寻找`1,2,4,3,1`这个排列的下一个排列，对于末尾`4,3,1	`肯定是不管怎么调整都是没有用的，因此我们需要对于前面的`2`进行调整，把它和`3`进行交换，然后把子序列进行翻转，最后得到`1,3,1,2,4`	

```c++
// 执行用时 :4 ms, 在所有 C++ 提交中击败了99.79%的用户
// 内存消耗 :9 MB, 在所有 C++ 提交中击败了76.64%的用户

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i;
        for(i = nums.size() - 1; i > 0; i--){
            if(nums[i - 1] < nums[i]){
                break;
            }
        }
        reverse(nums.begin() + i, nums.end());

        if(i != 0){
            for(int j = i; j < nums.size(); j++){
                if(nums[j] > nums[i - 1]){
                    swap(nums[i - 1], nums[j]);
                    break;
                }
            }
        }
    }
};
```

